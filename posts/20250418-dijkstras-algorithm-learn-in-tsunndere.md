---
title: "ツンデレで学ぶダイクストラ法"
date: "2025-04-18"
---

ふ、ふん。別にアンタのために書いてあげるわけじゃないんだからね！勘違いしないでよね！

このドキュメントは、ダイクストラ法について解説したものよ。グラフの基本から始めて、最短経路問題を解くためのアルゴリズムを丁寧に説明していくわ。初心者でも理解できるように、図や例をたくさん使って解説するから、安心して読み進めてちょうだい。…べ、別にアンタが理解できるかどうか心配してるわけじゃないんだからね！

## レジュメ

1.  **導入**:
    - グラフの基本概念（ノード、エッジ、重み）の説明
    - 隣接行列によるグラフの表現方法
2.  **例題**:
    - 最短経路問題を定義
    - 入力形式と出力形式を提示
3.  **ダイクストラ法の解説**:
    - ダイクストラ法の解説
    - 図を用いたアルゴリズムの実行例
    - アルゴリズムが正しく動作する理由の説明
4.  **計算量**:
    - ダイクストラ法の計算量の分析 ($O(n^2)$)
5.  **プログラム例**:
    - ナイーブな疑似コード
    - Priority First Search (PFS) というダイクストラ法の最適化手法の紹介
6.  **注意点**:
    - 負の重みを持つグラフに対するダイクストラ法の限界
    - Bellman-Ford 法の紹介
7.  **時刻表ベースのダイクストラ法**

## 1. 導入

### 1.1 グラフとはなんですか？

べ、別にアンタのために教えてあげるわけじゃないんだからね！勘違いしないでよね！

グラフっていうのはね、ノード（節点、node）とエッジ（辺、edge）で構成されるデータの表現形式のことよ。ノードは「頂点（vertex）」、エッジは「枝（branch）」って呼ばれることもあるわ。

- **ノード（Node）**: 情報を格納する場所、つまりデータの要素ね。丸で表現されることが多いわ。
- **エッジ（Edge）**: ノード同士をつなぐ線のこと。ノード間の関係性を示すの。エッジには「重み（weight）」が関連付けされている場合もあるわ。これはノード間の距離やコストを表すのよ。

グラフには大きく分けて 2 種類あるわ。

1.  **無向グラフ（Undirected Graph）**: エッジに方向がないグラフ。つまり、エッジで繋がれたノード同士は双方向に移動できるってこと。
2.  **有向グラフ（Directed Graph）**: エッジに方向があるグラフ。エッジは片方向にしか移動できないの。

```mermaid
graph LR
    a((a)) -- 1 --- b((b))
    a -- 7 --- c((c))
    a -- 2 --- d((d))
    b -- 2 --- e((e))
    b -- 4 --- f((f))
    c -- 2 --- f
    c -- 3 --- g((g))
    d -- 5 --- g
    e -- 1 --- f
    f -- 6 --- h((h))
    g -- 2 --- h
```

### 1.2 グラフってどうやってコンピュータで表現するのですか？

隣接行列っていう表を使ってグラフを表現することができるわ。行列の各要素は、ノード間にエッジがある場合はその「重み」を、ない場合は「-」で表すの。同一ノード間の重みは 0 とするのが一般的ね。

|     | a   | b   | c   | d   | e   | f   | g   | h   |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| a   | 0   | 1   | 7   | 2   | -   | -   | -   | -   |
| b   | 1   | 0   | -   | -   | 2   | 4   | -   | -   |
| c   | 7   | -   | 0   | -   | -   | 2   | 3   | -   |
| d   | 2   | -   | -   | 0   | -   | -   | 5   | -   |
| e   | -   | 2   | -   | -   | 0   | 1   | -   | -   |
| f   | -   | 4   | 2   | -   | 1   | 0   | -   | 6   |
| g   | -   | -   | 3   | 5   | -   | -   | 0   | 2   |
| h   | -   | -   | -   | -   | -   | 6   | 2   | 0   |

…ま、こんなところかしら。

## 2. 例題

### 2.1 どんな問題を扱いますか？

今回扱うのは、主に**最短経路問題**よ。いくつかの都市と、それらの都市をつなぐ道路の距離が与えられたとき、出発地点と目的地点が与えられた場合に、**最も短い経路**を探す問題のこと。

例題を出すわね。

「いくつかの都市と、それらの都市をつなぐ道路の距離が与えられている。出発地点と目的地点が与えられたとき、最短経路を探すプログラムを作りなさい。」

入力形式はこんな感じ。

```
N  R
A1 B1 L1
A2 B2 L2
...
AR BR LR
S  D
```

この表は、ある地図の情報をまとめたものなの。その地図には、いくつかの**都市**と、都市同士をつなぐ**道**があるのよ。

#### N R

これは、地図全体の情報を表しているわ。

**N** は、その地図に全部でいくつの**都市**があるかを表す数字よ。例えば、N が 5 だったら、都市が 5 つあるってこと。

$$1 \leqq N \leqq 100$$

**R** は、都市と都市をつなぐ**道**が全部で何本あるかを表す数字。R が 7 だったら、道が 7 本あるってことね。

#### A1 B1 L1

2 行目以降だけど、これは 1 本 1 本の道の情報を表しているわ。R 行にわたって $A_i$, $B_i$, $L_i$ $\left(1 \leqq i \leqq R\right)$ が続くの。

**A1** と **B1** は、その道がつないでいる 2 つの都市の名前（番号）よ。例えば、A1 が 0 で B1 が 1 だったら、0 番の都市と 1 番の都市がその道でつながっているってこと。**L1** は、その道の**長さ**（距離）を表す数字よ。

同じように、**A2 B2 L2**, **A3 B3 L3**,... と続いて、すべての道の情報が書かれているの。

$$0 \leqq A_i \leqq N-1$$

$$0 \leqq B_i \leqq N-1$$

#### S D

これは、出発点と目的地を表しているわ。

- **S** は、**出発点**の都市の名前（番号）。
- **D** は、**目的地**の都市の名前（番号）。

$$0 \leqq S \leqq N-1$$

$$0 \leqq D \leqq N-1$$

つまり、この表全体で、

「地図に都市が N 個と道が R 本あって、それぞれの道はどの都市とどの都市をつないでいて、長さはどれくらいで、今、都市 S から都市 D まで行きたいんだけど、どうすれば一番短い距離で行けるかな？」

っていう問題を表しているのよ。

### 2.2 入力と出力についてもういちど教えてください

もう、仕方がないんだから…入力をまとめておくわね。

- 最初の行には都市の数 $N$ と道の個数 $R$ が与えられるわ。
- 次の $R$ 行には、道の両端の都市 $A_i$, $B_i$ と道の距離 $L_i$ が与えられるの。
- 最後の行には、出発地点の都市 $S$ と目的地点の都市 $D$ が与えられるわ。

出力形式はこうよ。

- 答が見つかった場合は、最初の行に「最短経路の距離」を、次の行に「最短経路を辿ったときの都市を、出発地点から目的地点まで順にスペースを１個ずつあけて」出力するの。
- もし答えがない場合は、"No route" と出力するわ。

## 3. ダイクストラ法の解説

### 3.1 ダイクストラ法ってなんですか？

ダイクストラ法っていうのはね、グラフの中で、ある出発点から他の点への最短経路を一か所ずつ求めて、少しずつ範囲を広げていくアルゴリズムのことよ。ただし、グラフのエッジ（辺）の重みがすべて 0 以上の場合にしか使えないの。

簡単に言うと、

1.  まず、出発点からの距離がまだ確定していないすべての点に対して、とりあえず無限大（$∞$）の距離を設定するの。出発点自身の距離は 0 にするわ。
2.  次に、距離が確定していない点の中から、出発点からの距離が最も小さい点を選ぶの。
3.  選んだ点を「確定」させて、その点から直接つながっている他の点への距離を更新するわ。つまり、選んだ点を経由した場合の距離が、今までの距離よりも小さければ、その距離を新しい距離として採用するのよ。
4.  このステップ 2 と 3 を、すべての点の距離が確定するまで繰り返すの。

### 3.2 よくわからないので、図を描いてください

わ、分かったわよ！別にアンタのために作るわけじゃないんだからね！ただ、説明するのに便利だから作ってあげるだけなんだから！

ここでは、簡単な例として、以下のグラフでダイクストラ法を実行する様子を示すわ。

```mermaid
graph LR
    A((A)) ---|1| B((B))
    A ---|2| C((C))
    B ---|3| D((D))
    C ---|4| D
    B ---|5| E((E))
    D ---|6| E
```

このグラフで、A を出発点として、各ノードへの最短経路を求めるわよ。

1\. **初期状態**: すべてのノードの距離を無限大に設定し、出発点 A の距離を 0 にするわ。

```mermaid
graph LR
    A((A: 0))
    B((B: ∞))
    C((C: ∞))
    D((D: ∞))
    E((E: ∞))
    A ---|1| B
    A ---|2| C
    B ---|3| D
    C ---|4| D
    B ---|5| E
    D ---|6| E
```

2\. A までの最短距離を確定するわ。

```mermaid
graph LR
    subgraph 確定
	    A((A: 0))
	end
    B((B: ∞))
    C((C: ∞))
    D((D: ∞))
    E((E: ∞))
    A ---|1| B
    A ---|2| C
    B ---|3| D
    C ---|4| D
    B ---|5| E
    D ---|6| E
```

3\. A が直近で確定したから、 A 経由で到達できてかつ未確定の B と C を検討するわ。距離がもし既に書き込まれていた距離よりも小さかったとき、更新するの。今回は ∞ が書き込まれていたので、すべて更新するわね。

```mermaid
graph LR
    subgraph 確定
	    A((A: 0))
	end
    B((B: 1))
    C((C: 2))
    D((D: ∞))
    E((E: ∞))
    A -->|1| B
    A -->|2| C
    B ---|3| D
    C ---|4| D
    B ---|5| E
    D ---|6| E
```

4\. 未確定のなかから最も距離が小さい地点を探すと、 B までの最短距離が確定するわ。

```mermaid
graph LR
    subgraph 確定
	    A((A: 0))
		B((B: 1))
	end
    C((C: 2))
    D((D: ∞))
    E((E: ∞))
    A -->|1| B
    A -->|2| C
    B ---|3| D
    C ---|4| D
    B ---|5| E
    D ---|6| E
```

3\. B が直近で確定したから、B を経由し、かつ未確定の地点 E, D までの距離を計算して、もし既に書き込まれていた距離よりも小さかったとき、距離を更新するわ。今回も ∞ が書き込まれていたので、すべて更新するわね。

```mermaid
graph LR
	subgraph 確定
	    A((A: 0))
	    B((B: 1))
	end
    C((C: 2))
    D((D: 4))
    E((E: 6))
    A -->|1| B
    A -->|2| C
    B -->|3| D
    C ---|4| D
    B -->|5| E
    D ---|6| E
```

4\. 未確定のなかから距離が最も小さい地点を探すと、C が確定するわ。

```mermaid
graph LR
	subgraph 確定
	    A((A: 0))
	    B((B: 1))
	    C((C: 2))
	end
    D((D: 4))
    E((E: 6))
    A -->|1| B
    A -->|2| C
    B -->|3| D
    C ---|4| D
    B -->|5| E
    D ---|6| E
```

5\. C が直近で確定したから、C を経由し、かつ未確定の地点 D までの距離を計算して、もし既に書き込まれていた距離よりも小さかったとき、距離を更新するわ。今回は距離が 6 だから、更新は無いわね。

```mermaid
graph LR
	subgraph 確定
	    A((A: 0))
	    B((B: 1))
	    C((C: 2))
	end
    D((D: 4))
    E((E: 6))
    A -->|1| B
    A -->|2| C
    B -->|3| D
    C ---|4| D
    B -->|5| E
    D ---|6| E
```

6\. 未確定のなかから距離が最も小さい地点を探すと、D が確定するわ。

```mermaid
graph LR
	subgraph 確定
	    A((A: 0))
	    B((B: 1))
	    C((C: 2))
	    D((D: 4))
	end
    E((E: 6))
    A -->|1| B
    A -->|2| C
    B -->|3| D
    C ---|4| D
    B -->|5| E
    D ---|6| E
```

7\. D が直近で確定したから、D を経由し、かつ未確定の地点 E までの距離を計算して、もし既に書き込まれていた距離よりも小さかったとき、距離を更新するわ。今回は距離が 10 だから、更新は無いわね。

```mermaid
graph LR
	subgraph 確定
	    A((A: 0))
	    B((B: 1))
	    C((C: 2))
	    D((D: 4))
	end
    E((E: 6))
    A -->|1| B
    A -->|2| C
    B -->|3| D
    C ---|4| D
    B -->|5| E
    D ---|6| E
```

8\. 未確定のなかから距離が最も小さい地点を探すと、E が確定するわ。

```mermaid
graph LR
    A((A: 0))
    B((B: 1))
    C((C: 2))
    D((D: 4))
    E((E: 6))
    A -->|1| B
    A -->|2| C
    B -->|3| D
    C ---|4| D
    B -->|5| E
    D ---|6| E
```

9\. これで、すべてのノードの距離が確定したわ。最短経路は A → B → E で、距離は 6 ね。

```mermaid
graph LR
    A((A: 0))
    B((B: 1))
    C((C: 2))
    D((D: 4))
    E((E: 6))
    A ==>|1| B
    A -->|2| C
    B -->|3| D
    C ---|4| D
    B ==>|5| E
    D ---|6| E
```

## 3.3 どうしてこれでうまくいくのですか？

ダイクストラ法がうまくいく理由はね、簡単に言うと「**一度確定したノードへの最短距離は、後から覆ることがない**」からなの。

ちょっと難しいけど、順を追って説明するわね。

1.  **初期状態**: まず、出発点以外のすべてのノードへの距離を無限大（$∞$）に設定するわよね。これは、「まだどこを通って行けばいいか分からないから、とりあえずめちゃくちゃ遠い」って意味なの。出発点自身の距離は 0 よ。
2.  **距離が確定したノード**: アルゴリズムが進むにつれて、いくつかのノードへの最短距離が確定していくわ。この「確定」っていうのがミソなのよ。
3.  **確定ノードの重要性**: あるノード X への最短距離が確定したということは、出発点からノード X への**これ以上短い経路は絶対に存在しない**ってことが保証されているの。
4.  **なぜ保証されるのか**:
    - ダイクストラ法は、常に「距離が確定していないノードの中で、出発点からの距離が最も小さいノード」を選ぶわよね。
    - もし、ノード X へのもっと短い経路が存在するとしたら、その経路は必ず、まだ距離が確定していないノードを経由しているはずなの。
    - でも、ダイクストラ法は「距離が確定していないノードの中で、出発点からの距離が最も小さいノード」を順番に確定していくから、ノード X へのもっと短い経路が存在するはずがないのよ！
    - なぜなら、もしノード X へのもっと短い経路が存在するなら、その経路の途中のどこかに、ノード X よりも出発点からの距離が小さい未確定ノードが存在するはずだから。でも、そんなノードは、すでに確定されているはずなのよ！
5.  **エッジの重みが 0 以上**: ここで重要なのが、グラフのエッジの重みがすべて 0 以上であること。もし負の重みのエッジが存在すると、すでに確定したノードを経由することで、さらに短い経路が見つかってしまう可能性があるの。だから、ダイクストラ法は負の重みのエッジを持つグラフには使えないのよ。
6.  **繰り返しの意味**: ダイクストラ法は、この「確定」のプロセスを繰り返すことで、出発点からすべてのノードへの最短経路を徐々に明らかにしていくの。

つまりね、ダイクストラ法は、

「**今分かっている範囲で一番近いところに、順番にたどり着いていく。そして、一度たどり着いた場所は、もう二度と覆らない**」

っていう、とっても慎重な方法なのよ。

## 4. 計算量

### 4.1 計算量が気になります

ダイクストラ法の計算量は $O(n^2)$ になるわよ。ここで、$n$ はノード（頂点）の数ね。

#### 4.1.1 $O$ ってなんですか？

O 記法（Big O notation）っていうのはね、アルゴリズムの**計算量**や**空間量**が、入力サイズに対して**どれくらいの割合で増加するか**を表すための記法なの。

簡単に言うと、アルゴリズムの性能を**ざっくり**評価するためのものよ。

- **計算量**: アルゴリズムが問題を解くのにかかる時間（ステップ数）のこと。
- **空間量**: アルゴリズムが問題を解くのに必要なメモリの量のこと。

O 記法では、**最も影響の大きい部分**だけに着目するの。例えば、あるアルゴリズムの計算量が $3n^2 + 5n + 10$ だった場合、O 記法では $O(n^2)$ と表すわ。なぜなら、$n$ が大きくなるにつれて、$n^2$ の項が他の項よりも圧倒的に大きくなるからよ。

O 記法の代表的な例としては、以下のようなものがあるわ。

- $O(1)$: 入力サイズに関わらず、計算量が一定。
- $O(\log n)$: 入力サイズが 2 倍になると、計算量が少しだけ増加。
- $O(n)$: 入力サイズが 2 倍になると、計算量も 2 倍になる。
- $O(n \log n)$: 入力サイズが 2 倍になると、計算量は 2 倍より少しだけ増加。
- $O(n^2)$: 入力サイズが 2 倍になると、計算量は 4 倍になる。
- $O(2^n)$: 入力サイズが 1 増えると、計算量が 2 倍になる。

O 記法を使うことで、アルゴリズムの性能を簡単に比較したり、大規模なデータに対するアルゴリズムの適用可能性を判断したりすることができるのよ。

#### 4.1.2 ダイクストラ法の計算量はなぜ $O(n^2)$ になるのですか？

これは、主に以下の 2 つのステップがボトルネックになるからよ。

1.  **未確定ノードの中から最小距離のノードを探す**:
    - ダイクストラ法では、各ステップで「まだ最短距離が確定していないノードの中から、出発点からの距離が最も小さいノード」を選ぶ必要があるわよね。
    - ナイーブな実装（つまり、一番単純な実装）では、これを毎回、未確定のノードをすべて調べて探すことになるの。
    - 未確定のノードは、最初は $n$ 個あるけど、アルゴリズムが進むにつれて徐々に減っていくわ。
    - でも、最悪の場合（例えば、グラフがほとんど連結していない場合）、毎回 $n$ 個のノードを調べる必要があるのよ。
    - したがって、このステップの計算量は $O(n)$ になるわ。
2.  **選んだノードに隣接するノードの距離を更新する**:
    - 最小距離のノードを選んだら、次に、そのノードに隣接するノードの距離を更新する必要があるわよね。
    - つまり、「選んだノードを経由した場合の距離が、今までの距離よりも小さければ、その距離を更新する」っていう処理を行うの。
    - あるノードに隣接するノードの数は、最大で $n-1$ 個よ（自分自身を除くすべてのノード）。
    - したがって、このステップの計算量も $O(n)$ になるわ。

ダイクストラ法では、これらのステップをすべてのノードが確定するまで繰り返す必要があるわ。つまり、$n$ 回繰り返すの。

したがって、全体の計算量は、

$O(n) \times O(n) = O(n^2)$

となるわけ。

## 5 プログラム例

### 5.1 プログラムはどうやって書けばいいですか？

しょうがないわね…疑似コードを見せてあげるわ。[岩通ソフトシステム株式会社のウェブサイト](https://www.iwass.co.jp/column/column-03.html) からの引用よ！

```
DA（スタートノード、ゴールノード） ｛

　　全てのノードに未訪問と重みとして十分大きな値を設定します。

　　処理対象のノード（下記参照）がある限り繰り返します。｛
　　　　未訪問で重みが十分大きくないノードの中で一番重みが小さいノードを処理対象のノードとします。
　　　　処理対象のノードが見つからなければ、繰り返しを抜けます。
　　　　処理対象ノードのすべてのエッジについて繰り返します。｛
　　　　　　処理対象のノードの重みとエッジの重みを足したものが、行き先のノードに設定済の重みよりも小さければ、
　　　　　　行き先ノードの重みに小さい重み（上で加算した重み）を設定します。
　　　　｝
　　｝
　呼び出し元にゴールノードの重みを返します。
｝
```

### 5.2 実際の実装では何か工夫はありますか？

も、もしかしてアンタ、Priority First Search に興味があるの…？べ、別にアンタが賢くなろうとしてるからって、感心してるわけじゃないんだからね！

Priority First Search（優先度付き探索）っていうのはね、ダイクストラ法を**ちょっと賢くした**アルゴリズムのことよ。特に、グラフが**疎**（つまり、ノードの数に比べてエッジの数が少ない）の場合に効果を発揮するわ。

ダイクストラ法のナイーブな実装では、毎回「未確定ノードの中から最小距離のノードを探す」っていう処理が必要だったわよね。この処理が、$O(n)$ の計算量になって、全体の計算量を $O(n^2)$ に押し上げていたの。

Priority First Search では、この「最小距離のノードを探す」っていう処理を、**もっと効率的に**行うために、**優先度付きキュー**（Priority Queue）っていうデータ構造を使うの。

優先度付きキューっていうのはね、要素に優先度をつけて管理するキューのこと。優先度の高い要素から順番に取り出すことができるのよ。

具体的には、以下の 2 つの工夫をするわ。

1.  **未確定ノードの管理に優先度付きキューを使う**:
    - 未確定ノードをすべて優先度付きキューに入れておくの。
    - 各ノードの優先度は、出発点からの距離とするわ。
    - こうすることで、「最小距離のノードを探す」っていう処理を、$O(\log n)$ の計算量で行うことができるのよ。
2.  **ノードの接続関係に隣接リストを使う**:
    - グラフのノードの接続関係を、隣接行列ではなく**隣接リスト**で表現するの。
    - 隣接リストっていうのは、各ノードに対して、そのノードに隣接するノードのリストを保持するデータ構造のこと。
    - 疎なグラフの場合、隣接リストを使うことで、メモリの使用量を大幅に削減できるのよ。

これらの工夫によって、Priority First Search の計算量は、以下の 2 つになるわ。

- $O(n)$: これは、ダイクストラ法のメインループの繰り返し回数を表しているわ。ダイクストラ法では、各ノードに対して、最短距離を確定させる処理を行うから、メインループは $n$ 回繰り返されるのよ。
- $O( \log n + 定数)$: これは、メインループの中で行われる処理の計算量を表しているわ。具体的には、以下の 2 つの処理の計算量を合計したものよ。
  - $O(\log n)$: 優先度付きキューから最小距離のノードを取り出す処理の計算量。
  - $定数$: 最小距離のノードに隣接するノードの距離を更新する処理の計算量。疎なグラフの場合、各ノードに隣接するノードの数は少ないから、この処理の計算量は定数とみなせるのよ。

ここで、O 記法では、**最も影響の大きい部分**だけに着目するから、$\log n$ と $定数$ の和は、$O(\log n)$ とみなすことができるの。なぜなら、$n$ が大きくなるにつれて、$\log n$ の項が $定数$ の項よりも圧倒的に大きくなるからよ。

つまり、

$$O(n) \times O( \log n + 定数) = O(n) \times O(\log n) = O(n \log n)$$

したがって、Priority First Search の計算量は以下の式で表せるわ。

$$O(n \log n)$$

## 6. 注意点

#### 6.1 ダイクストラ法は万能ですか？

いいえ！グラフ中に負の重みのエッジがある場合はダイクストラ法では解けないわ！

必要があれば Bellman-Ford 法について調べてみなさい！

## 7 時刻表ベースのダイクストラ法

### 7.1 駅の乗換案内とかで使いたいです

乗り換え案内ね...ダイクストラの基本は分かったんでしょ？だったら話は早いわ！

時刻表を考慮する場合、通常のダイクストラ法に加えて、以下の点が重要になるわ。

### 7.2 ノードの拡張

通常のダイクストラ法では、ノードは単に「駅」を表すだけよね。でも、時刻表を考慮する場合は、「駅」と「その駅に到着する時刻」の組み合わせをノードとして扱う必要があるわ。

例えば、「東京駅 10:00」とか「大阪駅 13:30」みたいな感じね。

これは、同じ駅でも到着時刻が異なれば、その後の移動に影響を与えるからよ。

### 7.3 エッジの重み

エッジの重みは、駅間の移動時間だけじゃなくて、「待ち時間」も考慮する必要があるわ。

例えば、ある駅に 10:00 に到着して、次の列車が 10:30 に出発する場合、30 分の待ち時間が発生するわよね。この待ち時間もエッジの重みに含める必要があるの。

つまり、エッジの重み = 移動時間 + 待ち時間、ってこと。

### 7.4 ダイヤ情報の参照

各駅の出発時刻や到着時刻は、事前にダイヤ情報として与えられている必要があるわ。

ダイクストラ法でノードを探索する際に、このダイヤ情報を参照して、次のノード（駅と時刻の組み合わせ）を決定するの。

例えば、ある駅に 10:00 に到着した場合、ダイヤ情報を参照して、その駅からの次の出発時刻を調べる、ってことね。

### 7.5 優先度付きキュー

優先度付きキューには、「駅と時刻の組み合わせ」を、出発駅からの所要時間（移動時間 + 待ち時間）をキーとして格納するわ。

ダイクストラ法では、優先度付きキューから最も所要時間の短いノードを取り出して、そのノードから到達可能な次のノードを探索するの。

### 7.6 疑似コード

疑似コードを書いてみたわ。こうなるわよ！

```
時刻表付きDA（スタート駅, スタート時刻, ゴール駅） {

    // 各駅の時刻情報を保持するデータ構造（駅, 時刻）
    // (駅, 時刻)の組み合わせをノードとする
    // 各ノードに未訪問と重みとして十分大きな値を設定
    // 重みはスタート駅からの所要時間（移動時間 + 待ち時間）

    // スタートノードの重みを0に設定
    (スタート駅, スタート時刻) の重み = 0

    // 処理対象のノードがある限り繰り返す
    while (処理対象ノードが存在する) {
        // 未訪問で重みが最小のノードを処理対象ノードとする
        処理対象ノード = 未訪問ノードの中で重みが最小のノード

        // 処理対象ノードが見つからなければ、繰り返しを抜ける
        if (処理対象ノード == null) {
            break
        }

        // 処理対象ノードがゴール駅に到達したら、処理を終了
        if (処理対象ノード.駅 == ゴール駅) {
            return 処理対象ノード.重み
        }

        // 処理対象ノードから到達可能なすべてのノードについて繰り返す
        for (各エッジ in 処理対象ノード.駅からのエッジ) {
            // ダイヤ情報を参照して、次の駅への出発時刻を調べる
            次の出発時刻 = ダイヤ情報[処理対象ノード.駅].次の出発時刻(処理対象ノード.時刻)

            // 次の駅への移動時間
            移動時間 = エッジ.重み

            // 次の駅への到着時刻
            次の到着時刻 = 次の出発時刻 + 移動時間

            // 次の駅のノードを作成
            次のノード = (エッジ.行き先, 次の到着時刻)

            // 処理対象ノードの重みとエッジの重みを足したものが、行き先のノードに設定済の重みよりも小さければ、
            if (処理対象ノード.重み + (次の出発時刻 - 処理対象ノード.時刻) + 移動時間 < 次のノード.重み) {
                // 行き先ノードの重みを更新
                次のノード.重み = 処理対象ノード.重み + (次の出発時刻 - 処理対象ノード.時刻) + 移動時間
            }
        }
    }

    // ゴール駅に到達できなかった場合、無限大を返す
    return 無限大
}
```

## 終わりに

ふ、ふん。別にアンタのために書いてあげたわけじゃないんだからね！勘違いしないでよね！

このドキュメントでは、ダイクストラ法について解説したわ。グラフの基本から始まり、最短経路問題を解くためのアルゴリズム、計算量、プログラム例、そして注意点まで、幅広く噛み砕いたつもりよ。…べ、別にアンタが理解できるように頑張ったわけじゃないんだからね！

- 参考にしたのは [Nitta Lab., Computer Science, Tsuda University, Japan.](https://nw.tsuda.ac.jp/lec/dijkstra/?utm_source=pocket_saves) よ。大部分がこのサイトを噛み砕いたものになっているわ。
- 時刻表つきのダイクストラ法は [こぼれネット 江端智一のホームページ](https://wp.kobore.net/2024/01/06/post-13196/) を参考にしたわ。
- ダイクストラ法の疑似コードは [岩通ソフトシステム株式会社](https://www.iwass.co.jp/column/column-03.html) から引用したものよ。

出典元には感謝しなさいよね！
